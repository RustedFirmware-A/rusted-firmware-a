// Copyright The Rusted Firmware-A Contributors.
//
// SPDX-License-Identifier: BSD-3-Clause

//! Trace Buffer Extension (TRBE)
//! The TRBE is a trace buffer unit that stores trace generated by a trace unit into system memory.
//! For example, a TRBE could capture trace generated by a trace unit for a particular PE.
//!
//! The trace buffer has the following characteristics:
//!
//! - Can be physically or virtually addressed (normally virtually addressed).
//! - Has an owning translation regime.
//! - Is defined by pointer registers.
//! - Its operation is affected by external events like triggers.

use super::CpuExtension;

use crate::context::{CpuContext, World};

use arm_sysregs::{MdcrEl3, read_id_aa64dfr0_el1};

/// Enables Trace Buffer Extension for Non-secure world.
///
/// TRBE is an unusual feature. Its enablement is split into two:
///  - (NSTBE, NSTB\[0\]) - the security state bits - determines which security
///    state owns the trace buffer.
///  - NSTB\[1\] - the enable bit - determines if the security state that owns the
///    buffer may access TRBE registers.
///
/// There is a secondary id register TRBIDR_EL1 that is more granular than
/// ID_AA64DFR0_EL1. When a security state owns the buffer, TRBIDR_EL1.P will
/// report that TRBE programming is allowed. This means that the usual assumption
/// that leaving all bits to a default of zero will disable the feature may not
/// work correctly. To correctly disable TRBE, the current security state must NOT
/// own the buffer, irrespective of the enable bit. Then, to play nicely with
/// SMCCC_ARCH_FEATURE_AVAILABILITY, the enable bit should correspond to the
/// enable status. The feature is architected this way to allow for lazy context
/// switching of the buffer - a world can be made owner of the buffer (with
/// TRBIDR_EL1.P reporting full access) without giving it access to the registers
/// (by trapping to EL3). Then context switching can be deferred until a world
/// tries to use TRBE at which point access can be given and the trapping
/// instruction repeated.
///
/// This can be simplified to the following rules:
/// 1. To enable TRBE for world X:
///    world X owns the buffer ((NSTBE, NSTB\[0\]) == SCR_EL3.{NSE, NS})
///    trapping disabled (NSTB\[0\] == 1)
/// 2. To disable TRBE for world X:
///    world X does not own the buffer ((NSTBE, NSTB\[0\]) != SCR_EL3.{NSE, NS})
///    trapping enabled (NSTB\[0\] == 0)
pub struct TraceBufferNonSecure;

impl TraceBufferNonSecure {
    fn enable_ns(ctx: &mut CpuContext) {
        ctx.el3_state.mdcr_el3 |= MdcrEl3::NSTB_EN | MdcrEl3::NSTB_SS;
        ctx.el3_state.mdcr_el3 -= MdcrEl3::NSTBE;
    }

    fn disable(world: World, ctx: &mut CpuContext) {
        ctx.el3_state.mdcr_el3 -= MdcrEl3::NSTB_EN | MdcrEl3::NSTBE;

        if world == World::NonSecure {
            ctx.el3_state.mdcr_el3 -= MdcrEl3::NSTB_SS;
        } else {
            ctx.el3_state.mdcr_el3 |= MdcrEl3::NSTB_SS;
        }
    }
}

impl CpuExtension for TraceBufferNonSecure {
    fn is_present(&self) -> bool {
        read_id_aa64dfr0_el1().is_feat_trbe_present()
    }

    fn configure_per_cpu(&self, world: World, ctx: &mut CpuContext) {
        if world == World::NonSecure {
            // TODO: CORTEX_A510, CORTEX_A520, CORTEX_X4 may need to disable TRBE
            // if specific errata are applicable
            Self::enable_ns(ctx);
        } else {
            Self::disable(world, ctx);
        }
    }
}
